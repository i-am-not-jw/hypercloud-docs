= 스토리지 클래스 생성
:toc:
:toc-title:

본 장에서는 스토리지 클래스 리소스의 생성 방법에 대해서 설명한다.

== 폼 에디터

새로운 스토리지 클래스를 폼 에디터를 사용해서 생성할 수 있다.

. <<../console_menu_sub/storage#img-storage-class-main,스토리지 클래스 메인 화면>>에서 *[스토리지 클래스 생성]* 버튼을 클릭한다.
. *Create Storage Class* 화면이 열리면 **Configure via**를 "Form View"로 선택한다.
. 폼 에디터가 열리면 생성할 스토리지 클래스의 구성 정보를 설정한다. +
이때 설정 가능한 항목들은 다음과 같다. (* : 필수 입력 항목) 
+
NOTE: 각 항목에 대한 자세한 설명은 제품 내의 설명을 참고한다.

* Name *
* Labels
* allowVolumeExpansion
* Allowed Topologies +
하위 세부 항목은 xref:../form_set_item/form-set-item.adoc#<Allowed Topologies>["폼 에디터 설정 항목 참조"의 "Allowed Topologies"]를 참고한다.
* Mount Options
+
----
Value
----
* Parameters
+
----
KEY
VALUE
----
* provisioner *
* reclaimPolicy
* volumeBindingMode
. 설정이 완료되면 *[생성]* 버튼을 클릭해서 설정 내용을 저장한다.

== YAML 에디터

=== 블록 스토리지 클래스

새로운 블록 스토리지 클래스를 YAML 에디터를 사용해서 생성할 수 있다.

. <<../console_menu_sub/storage#img-storage-class-main,스토리지 클래스 메인 화면>>에서 *[스토리지 클래스 생성]* 버튼을 클릭한다.
. *Create Storage Class* 화면이 열리면 **Configure via**를 "YAML View"로 선택한다.
. YAML 에디터가 열리면 생성할 스토리지 클래스의 구성 정보를 설정한다.
+
.기본 작성 예
[source,yaml]
----
apiVersion: storage.k8s.io/v1
kind: StorageClass
metadata:
  name: rook-ceph-block <1>
provisioner: rook-ceph.rbd.csi.ceph.com
parameters:
  clusterID: rook-ceph <2>
  pool: replicapool <3>
  imageFormat: "2" <4>
  imageFeatures: layering <5>
    
  csi.storage.k8s.io/provisioner-secret-name: rook-csi-rbd-provisioner <6>
  csi.storage.k8s.io/provisioner-secret-namespace: rook-ceph <2>
  csi.storage.k8s.io/controller-expand-secret-name: rook-csi-rbd-provisioner <6>
  csi.storage.k8s.io/controller-expand-secret-namespace: rook-ceph <2>
  csi.storage.k8s.io/node-stage-secret-name: rook-csi-rbd-node <6>
  csi.storage.k8s.io/node-stage-secret-namespace: rook-ceph <2>
  csi.storage.k8s.io/fstype: ext4 <7>
    
#mounter: rbd-nbd <8>
allowVolumeExpansion: true <9>    
reclaimPolicy: Delete <10> 
----
+
<1> 스토리지 클래스의 이름
<2> Rook Ceph 클러스터가 설치된 네임스페이스의 이름 (기본값: rook-ceph) +
만약 기본값을 변경할 경우 secret의 네임스페이스도 변경 필요
<3> Ceph pool의 이름 (기본값: replicapool)
<4> RBD 이미지의 포맷 (기본값: 2) +
이미지 포맷을 1로 설정할 경우 deprecated되어 볼륨 cloning 등의 기능들은 사용할 수 없음
<5> RBD 이미지의 특성 (기본값: layering) +
현재 striping, exclusive-lock, object-map, fast-diff, deep-flatten, journaling 등은 미지원
<6> 오퍼레이터에 의해 생성된 Ceph 관리자의 secret (고정값)
<7> 스토리지의 파일 시스템 타입 (기본값: ext4)
<8> 볼륨을 마운트할 때 rbd-nbd 모듈의 사용 여부 (기본값: 미사용)
<9> 볼륨 크기 확장 기능의 지원 여부 (기본값: true)
<10> 사용이 끝난 영구 볼륨의 처리 방식 (기본값: Delete)
* Retain : 볼륨을 삭제하지 않고, 데이터를 보존
* Delete : 볼륨을 삭제
. 작성이 완료되면 *[생성]* 버튼을 클릭해서 작성 내용을 저장한다.

=== 파일 스토리지 클래스

새로운 파일 스토리지 클래스를 YAML 에디터를 사용해서 생성할 수 있다.

. <<../console_menu_sub/storage#img-storage-class-main,스토리지 클래스 메인 화면>>에서 *[스토리지 클래스 생성]* 버튼을 클릭한다.
. *Create Storage Class* 화면이 열리면 **Configure via**를 "YAML View"로 선택한다.
. YAML 에디터가 열리면 생성할 스토리지 클래스의 구성 정보를 설정한다.
+
.기본 작성 예
[source,yaml]
----
apiVersion: storage.k8s.io/v1
kind: StorageClass
metadata:
  name: csi-cephfs-sc <1>
provisioner: rook-ceph.cephfs.csi.ceph.com
parameters:
  clusterID: rook-ceph <2>
  fsName: myfs <3>
  pool: myfs-data0 <4>
    
    csi.storage.k8s.io/provisioner-secret-name: rook-csi-cephfs-provisioner <5>
    csi.storage.k8s.io/provisioner-secret-namespace: rook-ceph <2>
    csi.storage.k8s.io/controller-expand-secret-name: rook-csi-cephfs-provisioner <5>
    csi.storage.k8s.io/controller-expand-secret-namespace: rook-ceph <2>
    csi.storage.k8s.io/node-stage-secret-name: rook-csi-cephfs-node <5>
    csi.storage.k8s.io/node-stage-secret-namespace: rook-ceph <2>
    # mounter: kernel <6>
    
reclaimPolicy: Delete <7>
allowVolumeExpansion: true <8>    
mountOptions:
  #- debug <9>
----
+
<1> 스토리지 클래스의 이름
<2> Rook Ceph 클러스터가 설치된 네임스페이스의 이름 (기본값: rook-ceph) +
만약 기본값을 변경할 경우 secret의 네임스페이스도 변경 필요
<3> CephFS의 파일 시스템 이름 (기본값: myfs)
<4> Ceph pool의 이름 (기본값: myfs-data0)
<5> 오퍼레이터에 의해 생성된 Ceph 관리자의 secret (고정값)
<6> 볼륨을 마운트할 때 사용할 모듈 (기본값: 미사용) +
만약 해당 필드값을 작성하지 않으면 기본 volume mounter를 드라이버가 판단함
* fuse : ceph-fuse
* kernel : ceph kernelclient
<7> 사용이 끝난 영구 볼륨의 처리 방식 (기본값: Delete)
* Retain : 볼륨을 삭제하지 않고, 데이터를 보존
* Delete : 볼륨을 삭제
<8> 볼륨 크기 확장 기능의 지원 여부 (기본값: true)
<9> 마운트할 때 디버깅의 가능 여부 (기본값: 미사용)
. 작성이 완료되면 *[생성]* 버튼을 클릭해서 작성 내용을 저장한다.

=== nfs 스토리지 클래스 //(QA: 현재 샘플 예시로 추가된 볼륨과 파일 스토리지는 rook-ceph의 스토리지클래스인데 hypercloud5.0에서는 ceph 사용을 권장하지 않고, nfs나 san을 주로사용하게될 예정이므로 nfs 스토리지 클래스 생성 yaml을 sample로 변경 요청드립니다.)

새로운 nfs 스토리지 클래스를 YAML 에디터를 사용해서 생성할 수 있다.

. <<../console_menu_sub/storage#img-storage-class-main,스토리지 클래스 메인 화면>>에서 *[스토리지 클래스 생성]* 버튼을 클릭한다.
. *Create Storage Class* 화면이 열리면 **Configure via**를 "YAML View"로 선택한다.
. YAML 에디터가 열리면 생성할 스토리지 클래스의 구성 정보를 설정한다.
+
.기본 작성 예
[source,yaml]
----
apiVersion: storage.k8s.io/v1
kind: StorageClass
metadata:
  name: nfs (1)
provisioner: k8s-sigs.io/nfs-subdir-external-provisioner
parameters:
  onDelete: delete (2)
  pathPattern: "${.PVC.namespace}/${.PVC.name}" (3)
----
+
<1> 스토리지 클래스의 이름
<2> 사용이 끝난 영구 볼륨의 처리 방식 
* retain : 볼륨을 삭제하지 않고, 데이터를 보존
* delete : 볼륨을 삭제
<3> nfs 서버에 생성되는 dir 경로 형식
